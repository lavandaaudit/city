<!DOCTYPE html>
<html lang="uk">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>IBONIRIUM ¬∑ SPACE FOREST ¬∑ NEON CITY ¬∑ NOAA</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            background: #000;
            overflow: hidden;
            font-family: monospace;
            cursor: crosshair;
        }

        canvas {
            position: fixed;
            inset: 0;
        }

        #sensors {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            height: 180px;
            pointer-events: none;
        }

        #info {
            position: fixed;
            bottom: 12px;
            left: 12px;
            color: #9affc2;
            font-size: 11px;
            line-height: 1.5;
            opacity: 0.9;
            text-shadow: 0 0 8px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }

        #panel {
            position: fixed;
            bottom: 12px;
            right: 12px;
            max-width: 420px;
            color: #c7ffd9;
            font-size: 11px;
            line-height: 1.5;
            background: linear-gradient(to left, rgba(0, 0, 0, 0.75), transparent);
            padding: 14px 18px;
            border-right: 2px solid #0ff;
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.9);
            pointer-events: none;
        }

        #cycle {
            position: fixed;
            top: 12px;
            right: 12px;
            color: #ffd700;
            font-size: 13px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 14px;
            border-radius: 4px;
            pointer-events: none;
        }

        #treeInfo {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #0ff;
            padding: 20px;
            border-radius: 8px;
            color: #0ff;
            max-width: 400px;
            display: none;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        .close {
            float: right;
            cursor: pointer;
            color: #f00;
        }

        b {
            color: #0ff;
        }
    </style>
</head>

<body>
    <canvas id="stars"></canvas>
    <canvas id="aurora"></canvas>
    <canvas id="cityBack"></canvas>
    <canvas id="forestBack"></canvas>
    <canvas id="forestMid"></canvas>
    <canvas id="forestFront"></canvas>
    <canvas id="sensors"></canvas>

    <div id="info">
        <b>IBONIRIUM ¬∑ NEON CITY TIMELINE</b><br>
        Status: <span id="syncStatus">Syncing with 01.01.2026...</span><br>
        Cycle: <span id="cycleNum">1</span> | Day: <span id="dayNum">‚Äì</span><br>
        <br>
        <b>‚òÄ NOAA LIVE DATA</b><br>
        SSN: <span id="ssn">‚Äì</span> | Kp: <span id="kp">‚Äì</span> | Bz: <span id="bz">‚Äì</span><br>
        Wind: <span id="wind">‚Äì</span> km/s | Proton: <span id="proton">‚Äì</span><br>
        Flare: <span id="flare">None</span><br>
        <br>
        <b>‚ö° SYSTEM STATUS</b><br>
        Radiation: <span id="rad">Low</span><br>
        Storm Level: <span id="stormUI">Calm</span><br>
        City Power: <span id="powerUI">Stable</span><br>
        Trees: <span id="treeCount">‚Äì</span>
    </div>

    <div id="panel">
        <b>–í–Ü–ô–®–û–í –£ –†–ï–ñ–ò–ú –¢–ê–ô–ú–õ–ê–ô–ù–£</b><br>
        –ú—ñ—Å—Ç–æ —Ç–∞ –õ—ñ—Å —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–æ–≤–∞–Ω—ñ –∑ 1 —Å—ñ—á–Ω—è 2026.<br>
        <br>
        <div id="eternalTimer">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</div><br>
        - –ù–µ–æ–Ω–æ–≤–µ –º—ñ—Å—Ç–æ —Ç–∞ –õ—ñ—Å –≤–∏—Ä—ñ–≤–Ω—è–Ω—ñ –ø–æ –ª—ñ–Ω—ñ—ó –≥–æ—Ä–∏–∑–æ–Ω—Ç—É.<br>
        - <b>Sway Reaction:</b> –®–≤–∏–¥–∫—ñ—Å—Ç—å –∫–æ–ª–∏–≤–∞–Ω–Ω—è –¥–µ—Ä–µ–≤ –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ –≤—ñ—Ç—Ä—É.<br>
        - <b>Static Reaction:</b> –†–∞–¥—ñ–∞—Ü—ñ–π–Ω—ñ –∑–∞–≤–∞–¥–∏ –Ω–∞ —Å–µ–Ω—Å–æ—Ä–Ω—ñ–π –ø–∞–Ω–µ–ª—ñ.<br>
        - –î–µ—Ä–µ–≤–∞ —Ä–æ—Å—Ç—É—Ç—å –±–µ–∑–ø–µ—Ä–µ—Ä–≤–Ω–æ –±–µ–∑ –ø–µ—Ä—ñ–æ–¥–∏—á–Ω–∏—Ö —Å–∫–∏–¥–∞–Ω—å.
    </div>

    <div id="cycle">üîÑ CYCLE <span id="cycleDisplay">...</span></div>

    <div id="treeInfo" style="z-index: 9999;">
        <span class="close" onclick="event.stopPropagation(); this.parentElement.style.display='none'">‚úï</span>
        <h3>üå≤ Deep Scan</h3>
        <div id="treeDetails"></div>
    </div>

    <script>
        const canvases = ['stars', 'aurora', 'cityBack', 'forestBack', 'forestMid', 'forestFront', 'sensors'];
        const ctxs = {};
        canvases.forEach(id => {
            const c = document.getElementById(id);
            ctxs[id] = c.getContext('2d');
        });

        function resize() {
            canvases.forEach(id => {
                const c = document.getElementById(id);
                c.width = innerWidth;
                c.height = id === 'sensors' ? 180 : innerHeight;
            });
        }
        window.addEventListener('resize', resize); resize();

        // --- TIME ENGINE ---
        const START_DATE = new Date('2026-01-01T00:00:00');
        const MS_PER_CYCLE = 13 * 24 * 60 * 60 * 1000;
        const MS_PER_DAY = 24 * 60 * 60 * 1000;

        let timeline = {
            totalMs: 0,
            cyclesCompleted: 0,
            msInCurrentCycle: 0,
            progress: 0,
            dayInCycle: 0
        };

        function updateTimeline() {
            const now = new Date();
            timeline.totalMs = now - START_DATE;
            timeline.cyclesCompleted = Math.floor(timeline.totalMs / MS_PER_CYCLE);
            timeline.msInCurrentCycle = timeline.totalMs % MS_PER_CYCLE;
            timeline.progress = timeline.msInCurrentCycle / MS_PER_CYCLE;
            timeline.dayInCycle = Math.floor(timeline.msInCurrentCycle / MS_PER_DAY);

            const daysTotal = Math.floor(timeline.totalMs / MS_PER_DAY);
            const h = Math.floor((timeline.totalMs / 3600000) % 24);
            const m = Math.floor((timeline.totalMs / 60000) % 60);
            const s = Math.floor((timeline.totalMs / 1000) % 60);

            document.getElementById('cycleNum').textContent = timeline.cyclesCompleted + 1;
            document.getElementById('dayNum').textContent = timeline.dayInCycle;
            document.getElementById('cycleDisplay').textContent = (timeline.cyclesCompleted + 1) + " | DAY " + timeline.dayInCycle;
            document.getElementById('syncStatus').textContent = "Integrated Timeline Connected";
            document.getElementById('eternalTimer').innerHTML = `<b>–ß–∞—Å –±—É—Ç—Ç—è:</b> ${daysTotal}–¥ ${h}–≥ ${m}—Ö–≤ ${s}—Å`;
        }

        // --- NOAA & ENVIRONMENT ---
        let ssn = 0, kp = 0, bz = 0, solarWind = 400, protonFlux = 1, electronFlux = 100;
        let stormLevel = 0, radiationLevel = 0, auroraActive = false;
        let recentFlare = { class: 'None' };

        async function updateSpaceWeather() {
            try {
                const [rSSN, rProton, rFlare, rKp, rWind, rElectron] = await Promise.all([
                    fetch('https://services.swpc.noaa.gov/json/solar-cycle/predicted-solar-cycle.json').then(r => r.json()).catch(() => null),
                    fetch('https://services.swpc.noaa.gov/json/goes/primary/integral-protons-plot-6-hour.json').then(r => r.json()).catch(() => null),
                    fetch('https://services.swpc.noaa.gov/json/goes/primary/xray-flares-7-day.json').then(r => r.json()).catch(() => null),
                    fetch('https://services.swpc.noaa.gov/json/planetary_k_index_1m.json').then(r => r.json()).catch(() => null),
                    fetch('https://services.swpc.noaa.gov/json/rtsw/rtsw_wind_1m.json').then(r => r.json()).catch(() => null),
                    fetch('https://services.swpc.noaa.gov/json/goes/primary/integral-electrons-plot-6-hour.json').then(r => r.json()).catch(() => null)
                ]);

                if (rSSN) ssn = rSSN[rSSN.length - 1]?.predicted_ssn || 15;
                if (rProton) protonFlux = parseFloat(rProton[rProton.length - 1]?.flux) || 1;
                if (rKp) kp = parseFloat(rKp[rKp.length - 1]?.kp_index) || 0;
                if (rWind?.length) {
                    solarWind = parseFloat(rWind[rWind.length - 1].wind_speed) || 400;
                    bz = parseFloat(rWind[rWind.length - 1].bz) || 0;
                }
                if (rElectron) electronFlux = parseFloat(rElectron[rElectron.length - 1]?.flux) || 100;
                if (rFlare?.length) {
                    const latest = rFlare[rFlare.length - 1];
                    recentFlare = { class: latest.current_class || latest.max_class || 'None' };
                }

                let flareBoost = recentFlare.class.startsWith('X') ? 0.8 : recentFlare.class.startsWith('M') ? 0.3 : 0;
                radiationLevel = Math.min(1, (Math.log10(protonFlux + 1) / 5) + flareBoost);
                stormLevel = Math.min(1, (kp / 9) + (bz < 0 ? Math.abs(bz) / 20 : 0));
                auroraActive = kp >= 3;

                document.getElementById('ssn').textContent = ssn.toFixed(1);
                document.getElementById('kp').textContent = kp.toFixed(1);
                document.getElementById('bz').textContent = bz.toFixed(1);
                document.getElementById('wind').textContent = solarWind.toFixed(0);
                document.getElementById('proton').textContent = protonFlux.toFixed(2);
                document.getElementById('flare').textContent = recentFlare.class;

                document.getElementById('rad').textContent = radiationLevel < 0.3 ? 'Low' : radiationLevel < 0.7 ? 'Moderate' : 'High';
                document.getElementById('stormUI').textContent = stormLevel < 0.3 ? 'Calm' : stormLevel < 0.7 ? 'Active' : 'Storm';
                document.getElementById('powerUI').textContent = stormLevel > 0.6 ? 'Unstable' : 'Stable';
            } catch (e) { console.warn("Weather Sync Failed"); }
        }
        setInterval(updateSpaceWeather, 600000); updateSpaceWeather();

        // --- CITY ENGINE ---
        const buildings = Array.from({ length: 40 }, (_, i) => ({
            x: (i / 40),
            w: 0.02 + Math.random() * 0.04,
            h: 0.1 + Math.random() * 0.4,
            seed: Math.random() * 1000
        }));

        function drawCity() {
            const ctx = ctxs.cityBack;
            ctx.clearRect(0, 0, innerWidth, innerHeight);
            const pf = 0.015; // City parallax
            const baseY = innerHeight * 0.85; // Aligned horizon

            buildings.forEach(b => {
                const x = (b.x + (mouseX - 0.5) * pf) * innerWidth;
                const w = b.w * innerWidth;
                const h = b.h * innerHeight;
                const y = baseY - h + (mouseY - 0.5) * pf * 30;

                let hue = 190 + (bz < 0 ? Math.abs(bz) * 12 : 0) + stormLevel * 50;
                let brightness = 20 + Math.sin(Date.now() * 0.001 + b.seed) * 10;

                if (stormLevel > 0.6 && Math.random() < 0.1) brightness *= 2;

                ctx.fillStyle = `hsla(${hue}, 80%, ${brightness}%, 0.8)`;
                ctx.fillRect(x - w / 2, y, w, h);

                ctx.strokeStyle = `hsla(${hue}, 100%, 65%, ${0.3 + stormLevel * 0.5})`;
                ctx.lineWidth = 1;
                ctx.strokeRect(x - w / 2, y, w, h);

                // STATIC WINDOWS
                if (b.h > 0.2) {
                    ctx.fillStyle = `hsla(${hue + 40}, 100%, 80%, ${0.2 * (1 - stormLevel)})`;
                    for (let r = 1; r < 12; r++) {
                        for (let c = 0; c < 3; c++) {
                            if (Math.sin(b.seed + r * c) > 0) {
                                ctx.fillRect(x - w / 2 + c * (w / 4) + 2, y + r * (h / 15), w / 8, 2);
                            }
                        }
                    }
                }
            });
        }

        // --- FOREST EVOLUTION ---
        class DeterministicTree {
            constructor(id, layer) {
                this.id = id;
                this.x = (Math.abs(Math.sin(id * 456.789)) * 0.9) + 0.05;
                this.layer = layer;
                this.baseSeed = id * 123.456;
                this.screenX = 0; this.screenY = 0; this.screenR = 0;
            }

            getParams(cycle) {
                const seed = this.baseSeed + cycle;
                const rnd = (n) => Math.abs(Math.sin(seed * n));
                return {
                    type: Math.floor(rnd(1.1) * 4),
                    maxAge: 6 + rnd(1.2) * 4,
                    angle: 0.45 + rnd(1.3) * 0.4,
                    colorOff: rnd(1.4) * 40
                };
            }

            draw(ctx) {
                const cycle = timeline.cyclesCompleted;
                const p = this.getParams(cycle);
                const memory = cycle * 1.5;
                const age = (timeline.progress * p.maxAge) + memory;

                const scale = this.layer === 'back' ? 0.6 : this.layer === 'mid' ? 0.85 : 1.1;
                const opacity = this.layer === 'back' ? 0.4 : this.layer === 'mid' ? 0.7 : 1.0;
                const pf = this.layer === 'back' ? 0.02 : this.layer === 'mid' ? 0.05 : 0.1;

                let x = (this.x + (mouseX - 0.5) * pf) * ctx.canvas.width;
                let y = (ctx.canvas.height * 0.85) + (mouseY - 0.5) * pf * 50; // Aligned horizon

                let len = (50 + cycle * 10 + (ssn / 10)) * scale * (1 + (solarWind - 400) / 2000);
                let angle = -Math.PI / 2;
                let hue = 140 + p.colorOff - (radiationLevel * 80) + (stormLevel * 40);

                ctx.strokeStyle = `hsla(${hue}, 80%, ${50 + stormLevel * 20}%, ${opacity})`;
                ctx.lineWidth = 2;

                const steps = Math.min(30, Math.floor(age * 1.5));
                for (let i = 0; i < steps; i++) {
                    const nx = x + Math.cos(angle) * len;
                    const ny = y + Math.sin(angle) * len;
                    ctx.lineWidth = Math.max(1, len * 0.12 * (1 + stormLevel * 0.3));
                    ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(nx, ny); ctx.stroke();

                    // REACTION 1: Solar Wind Sway Turbulence
                    const swaySpeed = 0.001 + (solarWind / 200000);
                    angle += Math.sin(i * 1.5 + this.baseSeed + cycle + Date.now() * swaySpeed + stormLevel * 5) * p.angle;

                    x = nx; y = ny; len *= 0.68;
                }

                const crown = (10 + cycle * 3 + radiationLevel * 15) * scale * (1 + stormLevel);
                ctx.fillStyle = `hsla(${hue + 40}, 100%, 75%, ${opacity * 0.9})`;
                ctx.beginPath(); ctx.arc(x, y, crown, 0, Math.PI * 2); ctx.fill();
                this.screenX = x; this.screenY = y; this.screenR = crown * 2;

                if (stormLevel > 0.6) {
                    ctx.shadowBlur = 10 + stormLevel * 10; ctx.shadowColor = 'cyan';
                    ctx.lineWidth = 1; ctx.stroke(); ctx.shadowBlur = 0;
                }
            }
        }

        const forest = [];
        for (let i = 0; i < 85; i++) {
            const layer = i < 25 ? 'back' : i < 55 ? 'mid' : 'front';
            forest.push(new DeterministicTree(i, layer));
        }

        // --- AURORA ---
        const auroraWaves = Array.from({ length: 5 }, (_, i) => ({ phase: Math.random() * 10, speed: 0.005 + i * 0.002 }));
        function drawAurora() {
            const ctx = ctxs.aurora;
            ctx.clearRect(0, 0, innerWidth, innerHeight);
            if (!auroraActive && stormLevel < 0.3) return;
            const intensity = Math.max(stormLevel, auroraActive ? 0.7 : 0);
            auroraWaves.forEach((w, i) => {
                w.phase += w.speed;
                const grad = ctx.createLinearGradient(0, 0, 0, innerHeight * 0.45);
                grad.addColorStop(0, `hsla(140, 100%, 60%, ${intensity * 0.1})`);
                grad.addColorStop(0.5, `hsla(200, 100%, 50%, ${intensity * 0.2})`);
                grad.addColorStop(1, 'transparent');
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.moveTo(0, innerHeight * 0.3);
                for (let x = 0; x <= innerWidth; x += 20) {
                    const y = innerHeight * 0.3 + Math.sin(x * 0.01 + w.phase) * (40 + i * 10) * intensity;
                    ctx.lineTo(x, y);
                }
                ctx.lineTo(innerWidth, 0); ctx.lineTo(0, 0); ctx.fill();
            });
        }

        // --- INPUT ---
        let mouseX = 0.5, mouseY = 0.5;
        window.addEventListener('mousemove', e => {
            mouseX = e.clientX / innerWidth;
            mouseY = e.clientY / innerHeight;
        });

        window.addEventListener('click', e => {
            const target = forest.find(t => Math.sqrt((t.screenX - e.clientX) ** 2 + (t.screenY - e.clientY) ** 2) < t.screenR);
            if (target) {
                const cycle = timeline.cyclesCompleted;
                const p = target.getParams(cycle);
                document.getElementById('treeDetails').innerHTML = `
                    <b>ID:</b> NODE-${target.id}<br>
                    <b>Cycle:</b> ${cycle + 1}<br>
                    <b>Max Age:</b> ${p.maxAge.toFixed(1)}<br>
                    <b>Genetics:</b> Type ${p.type}<br>
                    <b>Stability:</b> ${((1 - radiationLevel) * 100).toFixed(0)}%
                `;
                document.getElementById('treeInfo').style.display = 'block';
            }
        });

        // --- RENDER ---
        const stars = Array.from({ length: 300 }, () => ({ x: Math.random(), y: Math.random(), s: Math.random() }));
        function drawStars() {
            const ctx = ctxs.stars;
            ctx.clearRect(0, 0, innerWidth, innerHeight);
            ctx.fillStyle = "white";
            stars.forEach(s => {
                ctx.globalAlpha = 0.1 + Math.sin(Date.now() * 0.001 + s.x * 10) * 0.4;
                ctx.beginPath(); ctx.arc(s.x * innerWidth, s.y * innerHeight, s.s * 1.5, 0, Math.PI * 2); ctx.fill();
            });
        }

        function loop() {
            updateTimeline();
            drawStars();
            drawAurora();
            drawCity();

            ['forestBack', 'forestMid', 'forestFront'].forEach(id => ctxs[id].clearRect(0, 0, innerWidth, innerHeight));

            forest.forEach(t => {
                if (t.layer === 'back') t.draw(ctxs.forestBack);
                else if (t.layer === 'mid') t.draw(ctxs.forestMid);
                else t.draw(ctxs.forestFront);
            });

            // HUD
            const sctx = ctxs.sensors;
            sctx.clearRect(0, 0, innerWidth, 180);

            // REACTION 2: Cosmic Noise HUD Interference
            if (radiationLevel > 0.4) {
                sctx.fillStyle = `rgba(255, 255, 255, ${radiationLevel * 0.15})`;
                for (let i = 0; i < 30; i++) {
                    sctx.fillRect(Math.random() * innerWidth, Math.random() * 180, 1, 1);
                }
            }

            sctx.fillStyle = "#ffd700";
            sctx.fillRect(50, 140, (innerWidth - 100) * timeline.progress, 4);
            sctx.font = "10px monospace";
            sctx.fillText("TIMELINE PROGRESS (CYCLE " + (timeline.cyclesCompleted + 1) + ")", 50, 130);

            requestAnimationFrame(loop);
        }

        document.getElementById('treeCount').textContent = forest.length;
        loop();
    </script>
</body>

</html>
